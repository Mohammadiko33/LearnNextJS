## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

<!-------------------------------------- start notes ---------------------------------->
# Episode 8 : RootLayout

### لیوت به چی میگن ؟ به چیزی که قراره دوتا کانتنت دوتا محتوایی رو در بر بگیره

### مثال برای لیوت : ما فوتر و ساید بار و هدر داشته باشیم و کانتتمون اون وسطه حالا ما نمیخایم توی هر صفحه ای که میریم هدروساید بار و فوتر رو بنویسیم یک لیوت میسازیم و کانتتمون اون وسط قرار میدیم

---

# Episode 12 : Layout vs Template

### وقتی اسم فایل رو میزاریم لیوت و توی اینپوت بنویسیم محمد وقتی توی صفحه های سویچ میکنیم اون ولیو خالی نمیشه 

### ولی وقتی اسم فایل تمپلیت باشه ولیو اینپوت خالی میشه

---

# Episode 14 : how to error handling in next

## ✅ 1. انواع ارورها در Next.js

در Next.js دو نوع ارور داریم:

### a) **Runtime Errors** (ارورهای زمان اجرا):

مثلاً `listItem.map()` وقتی `listItem` تعریف نشده باشه.

```ts
const listItem = undefined;
listItem.map(item => <div>{item}</div>); // ⚠️ کرش کامل صفحه
```

### b) **Handled Errors** (ارورهای مدیریت شده):

مثل ارورهایی که خودمون مثلاً در `try/catch` می‌ندازیم، مثلاً در `fetch()` یا `form`.

---

## ✅ 2. ساخت صفحه `error.tsx` در Next.js

در App Router، می‌تونی برای هر مسیر، یک `error.tsx` بسازی تا ارورهای اون صفحه یا لایه رو بگیره:

```
app/
└── (auth)/
    └── forget-password/
        ├── page.tsx
        └── error.tsx ✅ ← صفحه‌ی هندل ارور برای این مسیر
```

### مثال: error.tsx

```tsx
'use client'

export default function Error({ error, reset }: { error: Error; reset: () => void }) {
  return (
    <div className="text-center p-8 text-red-600">
      <h2>😓 یه مشکلی پیش اومده!</h2>
      <p>{error.message}</p>

      <button
        onClick={() => reset()}
        className="mt-4 bg-red-500 text-white px-4 py-2 rounded"
      >
        تلاش مجدد
      </button>
    </div>
  )
}
```

---

## ✅ 3. چطور ارور خودمون بندازیم؟

مثلاً در `page.tsx` فرم فراموشی رمز عبور:

```tsx
'use client'

import { useState } from 'react'

export default function ForgetPasswordPage() {
  const [email, setEmail] = useState('')

  const handleSubmit = async () => {
    try {
      const res = await fetch('/api/forget-password', {
        method: 'POST',
        body: JSON.stringify({ email }),
      })

      if (!res.ok) {
        throw new Error('ارسال ایمیل با خطا مواجه شد 😕')
      }

      alert('ایمیل ارسال شد ✅')
    } catch (error) {
      // ارور هندل میره تو error.tsx
      throw error // 💥 اگر این رو بندازی، میره به error.tsx در این مسیر
    }
  }

  return (
    <div>
      <h1>فراموشی رمز عبور</h1>
      <input value={email} onChange={e => setEmail(e.target.value)} />
      <button onClick={handleSubmit}>ارسال</button>
    </div>
  )
}
```

---

## ✅ 4. نکته مهم: ارور `listItem.map()` (یعنی ارورهای واقعی JavaScript)

وقتی ارور شدید مثل `undefined.map()` رخ بده، باید یک سطح بالاتر **error.tsx** تعریف کنیم تا جلوی کرش رو بگیره:

```
app/
└── auth/
    └── error.tsx ✅
```

در این صورت، حتی اگر `forget-password` ارور شدید داشت، اون صفحه‌ی error نمایش داده میشه.

---

## ⚠️ مشکل: چرا وقتی ارور بالا میاد layout نمیاد؟

به صورت پیش‌فرض `error.tsx` خارج از `layout.tsx` رندر میشه مگر اینکه در همون سطح باشن.

پس برای این که error در کنار layout نمایش داده بشه، باید **error.tsx و layout.tsx در یک سطح باشن**:

```FolderStructure
app/
└── auth/
    ├── layout.tsx ✅
    ├── error.tsx ✅
    └── forget-password/
        └── page.tsx
```

---

## 🎁 جمع‌بندی نکات مهم

| مورد                       | توضیح                                            |
| -------------------------- | ------------------------------------------------ |
| `error.tsx`                | فقط برای هندل کردن ارورهای اون مسیر استفاده میشه |
| ارورهای `throw`            | به error.tsx میرن                                |
| ارورهای `undefined.map()`  | باید در سطح بالاتر try/catch یا error.tsx باشه   |
| برای نمایش layout با error | error.tsx باید همسطح layout.tsx باشه             |

---

اگه خواستی برات یک پروژه دمو هم بسازم یا همین سناریو رو پیاده کنم. بگو می‌خوای با API Route باشه یا بدون؟

---

# Episode 15: Client-side Rendering

### وقتی ما یک وب‌سایتی با روش Client-side Rendering (CSR) می‌سازیم، اتفاقات به این صورت پیش می‌ره:

### ابتدا مرورگر کاربر یک درخواست (Request) به سرور می‌فرسته.

### در پاسخ، سرور فقط یک فایل ساده HTML ارسال می‌کنه. این فایل در ابتدا محتوای خاصی نداره (تقریباً خالیه یا فقط شامل یک div با id مشخص مثل root هست).

### بعد از اینکه HTML اولیه بارگذاری شد، مرورگر دوباره یک درخواست دیگه می‌فرسته تا فایل‌های JavaScript مربوطه (معمولاً فایل‌های React یا Next.js) رو دریافت کنه.

### وقتی JavaScript بارگذاری شد، اون فایل میاد و داخل مرورگر اجرا میشه.

### JavaScript با استفاده از فریم‌ورک‌هایی مثل React، محتوای واقعی صفحات رو داخل مرورگر می‌سازه و رندر می‌کنه. یعنی کار رندر شدن صفحات کاملاً در سمت کاربر (client) انجام می‌شه، نه روی سرور.

## 🧠 نتیجه:

### در روش Client-side Rendering، صفحات HTML کامل و واقعی بعد از بارگذاری JavaScript و اجرای اون در مرورگر ساخته می‌شن. به همین دلیل، ممکنه در بار اول، کمی زمان‌برتر باشه تا محتوای کامل صفحه نمایش داده بشه.

---

# Episode 16 : Server-side Rendering (SSR)

### وقتی ما از SSR استفاده می‌کنیم، اتفاقات به این شکل پیش می‌ره:

### وقتی کاربر وارد سایت می‌شه، مرورگر یک درخواست (Request) به سرور می‌فرسته.

### اما این بار، سرور خودش صفحه HTML کامل رو می‌سازه. یعنی سرور میاد داده‌ها رو می‌گیره، کامپوننت‌ها رو اجرا می‌کنه و خروجی نهایی HTML رو آماده می‌کنه.

### بعد از آماده شدن HTML، اون صفحهٔ کامل به مرورگر ارسال می‌شه.

### مرورگر اون صفحه رو نمایش می‌ده — تقریباً بلافاصله چون صفحه از قبل آماده بوده.

### بعد از اون، فایل‌های JavaScript جداگانه هم بارگذاری می‌شن تا تعاملات (مانند کلیک، فرم، سوییچ تب‌ها و ...) کار کنن.

## 🧠 نتیجه:

### در SSR، بر خلاف CSR، صفحهٔ نهایی در خودِ سرور ساخته می‌شه و بعد به کاربر فرستاده می‌شه. به همین دلیل، کاربر خیلی زودتر محتوای کامل رو می‌بینه و سئو (SEO) هم بهتره چون موتورهای جستجو می‌تونن محتوای کامل رو بخونن.

---
---

# Episode 17 : Pre CSR vs CSR vs SSR vs SSG vs ISR

# 📘 تفاوت انواع روش‌های رندر در وب: سایت‌های سنتی، CSR، SSR، SSG، ISR

---

## 🔹 0. Pre-CSR (یا سایت‌های سنتی HTML/CSS/JS)
> منظور از این حالت، سایت‌هایی هست که **فقط با HTML، CSS و JavaScript ساده ساخته می‌شن**، بدون فریم‌ورک‌هایی مثل React یا Vue.  
در این مدل، تمام فایل‌ها از سرور به مرورگر فرستاده می‌شن و مرورگر مستقیماً اون‌ها رو اجرا می‌کنه.  
این روش رایج‌ترین شکل توسعه وب قبل از ورود فریم‌ورک‌های SPA و CSR بود.

---

## 🔹 1. CSR (Client-Side Rendering)
> محتوای صفحه **توی مرورگر کاربر و به کمک JavaScript فریم‌ورک‌ها** ساخته می‌شه.  
معمولاً یک HTML ساده و خالی لود میشه، و بعد از اون JavaScript با استفاده از فریم‌ورک‌هایی مثل React/Vue صفحه رو کامل می‌سازه.

---

## 🔹 2. SSR (Server-Side Rendering)
> محتوای صفحه **روی سرور ساخته میشه** و یک HTML کامل به مرورگر فرستاده می‌شه.  
بعد از اون JavaScript برای تعاملات فعال می‌شه (hydration).

---
 
## 🔹 3. SSG (Static Site Generation)
> تمام صفحات در زمان build ساخته می‌شن و به شکل HTML ثابت ذخیره می‌شن.  
برای سایت‌هایی با محتوای کمتر پویا بسیار مناسب است.

---

## 🔹 4. ISR (Incremental Static Regeneration)
> شبیه SSG هست ولی با این تفاوت که **صفحات می‌تونن بعد از build هم به‌روزرسانی بشن**.  
تغییرات به صورت تدریجی و بدون نیاز به ری‌بیلد کامل اعمال می‌شن.

---

## 📊 مقایسه سریع و ساده

| روش            | زمان ساخت HTML         | محل ساخت         | سرعت بارگذاری اولیه | مناسب برای                | نکته مهم                         |
|------------------|--------------------------|---------------------|--------------------------|-----------------------------|-----------------------------------|
| Pre-CSR (سنتی)   | همزمان با درخواست       | مرورگر کاربر         | سریع                   | سایت‌های ساده و استاتیک   | بدون فریم‌ورک، بدون تعاملات پیشرفته |
| CSR              | بعد از بارگذاری JS      | مرورگر کاربر         | کندتر از SSR             | اپ‌های پویا و SPAها         | سئو ضعیف‌تر                      |
| SSR              | هنگام درخواست کاربر      | سرور                 | سریع                     | صفحات نیازمند داده لحظه‌ای | سئو عالی                         |
| SSG              | هنگام Build پروژه        | سرور                 | بسیار سریع               | بلاگ، مستندات، صفحات ثابت  | بدون نیاز به سرور قوی            |
| ISR              | ترکیبی: Build + تدریجی   | سرور                 | سریع + به‌روز            | فروشگاه، مقالات متغیر      | مقیاس‌پذیر، هوشمند و بهینه       |

---

## 🧠 مثال ساده برای درک تفاوت‌ها

فرض کنیم یک فروشگاه اینترنتی داریم:

- **Pre-CSR (سنتی)**: صفحه با HTML/CSS ساده لود میشه، بدون تعاملات پیچیده.
- **CSR**: کاربر ابتدا صفحه‌ای سفید می‌بینه، بعد از لود شدن JS محتوا نمایش داده میشه.
- **SSR**: سرور قبل از ارسال صفحه، HTML رو تولید می‌کنه و کاربر سریع محتوا رو می‌بینه.
- **SSG**: همه صفحات از قبل در زمان build آماده شده‌ان، سریع‌ترین بارگذاری.
- **ISR**: صفحات استاتیک هستن ولی می‌تونن به‌صورت هوشمند بعداً آپدیت بشن.

---
---

# Episode 18 : When use srever component and, When use clien component?

# 📘 راهنمای ساده انتخاب Client Component یا Server Component در React / Next.js

---

## 🧠 تفاوت اصلی:

- **Server Component:** روی سرور اجرا می‌شه، فایل جاوااسکریپتی برای کلاینت نمی‌فرسته، سریع‌تر لود می‌شه.
- **Client Component:** روی مرورگر اجرا می‌شه، به جاوااسکریپت نیاز داره و می‌تونه از تعامل کاربر استفاده کنه.

---

## ✅ چه زمانی از Server Component استفاده کنیم؟

- نیازی به تعامل کاربر نیست (مثل فرم، کلیک، تغییر وضعیت).
- می‌خوای اطلاعات از دیتابیس یا API در سرور بگیری و نمایش بدی.
- می‌خوای حجم جاوااسکریپت ارسالی به مرورگر رو کم کنی.
- از داده‌های امنیتی یا حساس استفاده می‌کنی که نباید به کلاینت برسن.

### مثال:
```jsx
// Server Component
async function ProductsPage() {
  const products = await getProductsFromDB();
  return (
    <div>
      {products.map((p) => <ProductCard key={p.id} {...p} />)}
    </div>
  );
}
````

---

## ✅ چه زمانی از Client Component استفاده کنیم؟

* کاربر باید با کامپوننت تعامل داشته باشه (مثل دکمه، فرم، انیمیشن، تغییر وضعیت).
* از state، useEffect یا event handler استفاده می‌کنی.
* می‌خوای تجربه تعاملی سمت کاربر بسازی (مثل مدال، تب، دراپ‌داون، اسلایدر، چک‌باکس).

### مثال:

```jsx
"use client";
import { useState } from "react";

function LikeButton() {
  const [liked, setLiked] = useState(false);
  return (
    <button onClick={() => setLiked(!liked)}>
      {liked ? "❤️ Liked" : "🤍 Like"}
    </button>
  );
}
```

---

## 📝 نکات کاربردی:

* همیشه اول از Server Component شروع کن.
* فقط زمانی `use client` بنویس که به تعامل، state یا effect نیاز داری.
* می‌تونی ترکیبی استفاده کنی (Server Wrapper → Client Component داخلش).
* Server Components بهتر برای SEO، سرعت اولیه، و حفاظت از داده‌ها هستن.

---

## 🧩 ترکیب مثال:

```jsx
// Server Component
import LikeButton from "./LikeButton"; // Client component

function BlogPost({ post }) {
  return (
    <article>
      <h1>{post.title}</h1>
      <p>{post.content}</p>
      <LikeButton />
    </article>
  );
}
```

---

## ✅ خلاصه تصویری

| ویژگی / نوع       | Server Component | Client Component   |
| ----------------- | ---------------- | ------------------ |
| اجرا روی          | سرور             | مرورگر (کلاینت)    |
| پشتیبانی از state | ❌                | ✅                  |
| تعامل کاربر       | ❌                | ✅                  |
| عملکرد اولیه سریع | ✅                | ❌                  |
| مناسب برای        | داده، SEO، امنیت | فرم، کلیک، انیمیشن |

---